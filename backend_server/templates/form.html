<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>Glossing UI</title>
    <link href='{{ url_for('static',filename='styles/style.css') }}' rel='stylesheet' type="text/css">
  </head>
  <body>
    <header>
        <h1>Glossing UI</h1>
        <p>Silfverberg Lab</p>

    </header>
    <article>
        <div class="form">
            <h2>Submit data</h2>
            <p>Please enter the text you wish to submit:</p>       
            <form>
                <textarea id=input_text></textarea>
                <p>Choose the model that you wish to use:</p>
                <div id="model_buttons">
                    <input type="radio" id="fairseq" 
                           name="model" value="fairseq" checked>
                    <label for="fairseq" class="model_button">fairseq</label>
                    <input type="radio" id="coling" 
                           name="model" value="coling">
                    <label for="coling" class="model_button">coling</label>
                </div>
            </form>
            <button class=job_buttons onclick="submit_job()">Submit</button>    
        </div>
    
        <div class="form">
            <h2>Get status of request</h2>
            <p>Enter job id:</p>
            <form id="input_job_id_form">
                <input type="number" id="input_job_id">
            </form>
            <button class=job_buttons onclick="checkStatus(document.getElementById('input_job_id').value)">
                Request job status
            </button>
            <div id="running_message" style="display:none">
                <p>Your job is running. This will automatically update, when your job is complete.</p>
            </div>
            <div id = "completed_message" style = "display:none">
                <h2>Request Results</h2>
                <div class=results_wrapper>
                    <table id="results_table">
                        <!-- here will be the results table -->
                    </table>
                </div>

                <div class="range_and_save">
                    <div id=legend>
                        <h3>Table Legend</h3>
                        <p class=input_token>Input token</p>
                        <p> Preferred segmentation</p>
                        <p id=segmentation_list_legend>List of n-best segmentations</p>
                    </div>

                    <p>Choose displayed token range:</p>
                    <div id=range_table_wrapper>
                        <table id="range_table">
                            <!-- range table will be here -->
                        </table>
                    </div>
                    <button id=save_changes_button class=job_buttons>Save changes</button>

                </div>

            </div>
        </div>
    </article>
    <footer>

    </footer>

    <script>
    // retrieve stored job id value from the browser. This makes it easy to see the result from the 
    // last job the user ran.
    document.getElementById("input_job_id").value = localStorage.getItem("last_job_id") || "";
    
    // This variable stores the timer that is used to automatically refresh the job status
    // while it is running.
    let timeout_result;

    /**
     * Checks the status of the job with jobId. If the job is complete, a table with 
     * results will appear. If the job is not complete, the function will check
     * again after a short interval.
     */
    async function checkStatus(jobId) {
        localStorage.setItem("last_job_id", String(jobId));
        // if we are waiting for a different job, we do not need to keep waiting for the previous one
        clearTimeout(timeout_result);
        // const jobId = document.getElementById("input_job_id").value;
        const status = await requestData(`/api/job/${jobId}`);
        const running_message = document.getElementById("running_message");
        const completed_message = document.getElementById("completed_message");
        // const completed_job = document.getElementById("completed_job");

        if (status.status) {
            // alert("Your job has completed.");
            running_message.style.display = "none";
            completed_message.style.display = "flex";
            // completed_job.value = "loading result";
            const result = await requestData(`/api/job/${jobId}/download`);
            const result_string = JSON.stringify(result);
            // completed_job.value = result_string;
            displayResultsPageTable(result_string, jobId);
            displayTable(result_string, 0, 100, jobId);
            // scroll to the results
            completed_message.scrollIntoView(true);
        } else {
            // alert("The job has submitted, but not completed yet. It is running. Rest assured you will be notified when it will get processed.");
            completed_message.style.display = "none";
            running_message.style.display = "block";
            // wait 2 s and run checkStatus again
            timeout_result = setTimeout(checkStatus, 2000, jobId);
        }
    }


    /**
     * Displays the results page table that allows to navigate between 
     * results pages (token ranges). 
     */
    function displayResultsPageTable(json_string, jobId) {
        let range_table = document.getElementById("range_table");
        const token_list = JSON.parse(json_string);
        const token_number = token_list.length;
        const range_rows = Math.ceil(token_number/100);
        const tokens_per_view = 100;
        let current_index = 0;
        range_table.innerHTML = "";
        for (i = 0; i < range_rows; i++) {
            let row = range_table.insertRow();
            let cell = row.insertCell();
            const range_button = document.createElement("button");
            range_button.setAttribute('class', 'range_button');
            const lower_bound = i*tokens_per_view;
            const upper_bound = i != range_rows - 1? (i+1)*tokens_per_view : token_number;
            range_button.value = `${lower_bound} - ${upper_bound}`;
            range_button.innerText = range_button.value;
            cell.appendChild(range_button);
            const current_i = i;
            range_button.onclick = () => {
                displayTable(json_string, lower_bound, upper_bound, jobId);
            }
        }
    }


    /**
     * Displays the results table.
     * 
     * Shows a subset of results starting from "start" token and
     * and ending at index "end" exclusive. Eg. start = 10, end = 20
     * will show tokens from 10 to 19. 
     * 
     * The table will contain at most 10 columns and at most 10 rows.
     */

    function displayTable(json_string, start, end, jobId) {
        let results_table = document.getElementById("results_table");
        // convert JSON to list of JS objects
        const token_list = JSON.parse(json_string);
        const tokens_included = end - start;
        const column_number = (tokens_included >= 10) ? 10 : tokens_included;
        const row_number = Math.ceil(tokens_included/10);
        let current_index = 0;
        results_table.innerHTML = ""; 
        // the outer loop will count up to ten, and break if there is less
        for (i = 0; i < row_number; i++) {
            const row = results_table.insertRow();
            for (j = 0; j < column_number; j++) {
                const current_token = current_index + start;
                if (current_token >= end) {
                    break;
                }

                const cell = row.insertCell();
                // allows users to select the whole cell with TAB
                cell.setAttribute('tabindex','0');

                // display input token in table cell
                const text = document.createElement("p");
                text.innerText = token_list[current_token]["input"];
                text.setAttribute('class', 'input_token');
                const break_line = document.createElement("br");
                cell.appendChild(text);
                cell.appendChild(break_line);

                // create input box for entering Custom option in 
                // segmentation list
                const custom_seg_input_field = document.createElement("input");
                custom_seg_input_field.setAttribute("type", "text");
                custom_seg_input_field.minlength = 1;
                // make this appear only if Custom option is selected in the drop down list.
                custom_seg_input_field.style.display = "none";
                cell.appendChild(custom_seg_input_field);

                // display the preferred segmentation
                const preferredSegmentation = document.createElement("p");
                preferredSegmentation.innerText = token_list[current_token]["preferred_segmentation"];
                cell.appendChild(preferredSegmentation);

                // Create custom select element with select list in it
                const custom_select = document.createElement("div");
                custom_select.setAttribute('class', 'custom-select');
                const selectList = document.createElement("select");
                selectList.id = "segmentation";
                custom_select.appendChild(selectList);
                cell.appendChild(custom_select);

                //Create array of options and add to the drop-down list
                const segmentation_list = token_list[current_token]["segmentation"];
                for (var i = 0; i < segmentation_list.length; i++) {
                    const option = document.createElement("option");
                    option.value = segmentation_list[i];
                    option.text = segmentation_list[i];
                    selectList.appendChild(option);
                }
                const custom_option = document.createElement("option");
                custom_option.value = "Custom"
                custom_option.text = "Custom"
                selectList.appendChild(custom_option);


                // Handlers

                // Handle choice from select list and display custom input box if Custom
                // option was thereby selected.
                selectList.onchange = () => {
                    const selectedOption = selectList.options[selectList.selectedIndex].value;
                    if ( selectedOption === custom_option.value) {
                        custom_select.style.display = "none";
                        custom_seg_input_field.style.display = "block";
                    } else {
                        token_list[current_token]["preferred_segmentation"] = selectedOption;
                    }
                    preferredSegmentation.innerText = token_list[current_token]["preferred_segmentation"];
                }

                // Sets the preferred segmentation based on 
                // user inputs and reverts to the list view
                custom_seg_input_field.onchange = () => {
                    token_list[current_token]["preferred_segmentation"] = custom_seg_input_field.value;
                    custom_seg_input_field.style.display = "none";
                    custom_select.style.display = "block";
                    preferredSegmentation.innerText = token_list[current_token]["preferred_segmentation"];
                }
                current_index++;
            }
        }

        const save_changes_button = document.getElementById("save_changes_button");

        save_changes_button.onclick = async () => {
            try {
                const saveRequestResult = await requestData(`/api/job/${jobId}/save`, token_list, 'POST');
                alert("Your save was successful");
            } catch (error) {
                alert("save was not successful");
            }
        }
    }


    /**
     * Keyboard controls for results table
     */ 
    window.onkeydown = (event) => {
        if (event.key === "ArrowRight") {
            changeCellFocus(1);
        } else if (event.key === "ArrowLeft") {
            changeCellFocus(-1);
        } else if (event.key === "ArrowDown") {
            changeSelectedInList(1);
        } else if (event.key === "ArrowUp") {
            changeSelectedInList(-1);
        }
    }

    function changeCellFocus(direction) {
        //  first figure out if a cell is selected
        let current_cell = document.querySelector("td:focus");
        const all_cells = document.querySelectorAll("#results_table td");
        let index_next;
        if (!current_cell) {
            index_next = 0;
        } else {
            index_next = Array.from(all_cells).indexOf(current_cell) + direction;
        }

        all_cells[index_next].focus();
        all_cells[index_next].scrollIntoView({block:"center"});
    }

    function changeSelectedInList(direction) {
        let current_cell = document.querySelector("td:focus");
        if (!current_cell) {
            return
        } else {
            let select_list = current_cell.querySelector("select");
            //  from MDN: to obtain modulo from remainder operator use ((a % n ) + n ) % n.
            select_list.selectedIndex = (((select_list.selectedIndex + direction) % select_list.length) + select_list.length) % select_list.length;
            event.preventDefault();
        }
    }

    /**
     * Submits a new job by making a POST request to the API
     * This will also prefill the job id in the get status form.
     **/
    async function submit_job() {
        const inputText = document.getElementById("input_text").value;
        const isFairseq = document.getElementById("fairseq").checked;
        const isColing = document.getElementById("coling").checked;
        let data;
        if (isFairseq) {
            data = {text:inputText, model:'fairseq'};
        } else {
            data = {text:inputText, model:'coling'};
        }
        const jobData = await requestData('/api/job', data, 'POST');
        document.getElementById("input_job_id").value = jobData.job_id;
        checkStatus(jobData.job_id);
    }


    /**
     * Helper function for a REST API request.
     */ 
    async function requestData(url = '', data = {}, method = 'GET') {
        // Default options are marked with *
        let response;
        try {
            response = await fetch(url, {
                method: method, // *GET, POST, PUT, DELETE, etc.
                credentials: 'include', // include, *same-origin, omit
                headers: {
                    'Content-Type': 'application/json'
                },
                body: method==='POST'? JSON.stringify(data) : undefined, 
                // body data type must match "Content-Type" header
            });
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
        } catch(err) {
            alert("Could not submit a request")
            throw err;
        }
        const job_data = await response.json();
        return job_data;
    }
    </script>
  </body>
</html>